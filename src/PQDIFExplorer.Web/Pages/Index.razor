@page "/"
@implements IDisposable

@using System.Linq
@using System.Threading

@inject IJSRuntime JSRuntime
@inject PQDIFFileCache Cache
@inject NavigationManager NavigationManager

<div>
    @if (FileKeys.Any())
    {
        @foreach (FileKeyData fileKey in FileKeys)
        {
            <div @key="fileKey.Key">
                <a href="@($"PQDIF/View/{fileKey.Key}")">
                    <img src="explorer.ico" width="20" height="20" /> @fileKey.Name
                </a>
                <a class="close-file" href="" @onclick="@(async _ => await Cache.PurgeAsync(fileKey.Key))" @onclick:preventDefault="true">
                    <span class="oi oi-x" title="Close" />
                </a>
            </div>
        }
    }

    <div>
        <input id="pqdif-file-input" class="d-none" type="file" accept=".pqd" @ref="FileInput" @onchange="@HandleFileAsync" />

        <a class="open-file @Disabled" type="button" href="" @onclick="@TriggerFileInputAsync" @onclick:preventDefault="true">
            <span class="oi oi-folder" /> Open...
        </a>
    </div>
</div>

@code {
    [CascadingParameter]
    private App? App { get; set; }

    private ElementReference FileInput { get; set; }

    private IEnumerable<FileKeyData> FileKeys { get; set; } =
        Enumerable.Empty<FileKeyData>();

    private CancellationToken LoadToken =>
        App?.LoadToken ?? default;

    private bool Loading =>
        LoadToken.CanBeCanceled &&
        !LoadToken.IsCancellationRequested;

    private string Disabled =>
        Loading ? "disabled" : string.Empty;

    protected override async Task OnInitializedAsync()
    {
        FileKeys = await Cache
            .RetrieveKeysAsync()
            .OrderBy(fileKey => fileKey.Name)
            .ToListAsync();

        Cache.Updated += HandleCacheUpdated;
    }

    public void Dispose()
    {
        Cache.Updated -= HandleCacheUpdated;
    }

    private void HandleCacheUpdated(object sender, EventArgs args)
    {
        Task<List<FileKeyData>> retrieveTask = Cache
            .RetrieveKeysAsync()
            .ToListAsync()
            .AsTask();

        retrieveTask.ContinueWith(task =>
        {
            FileKeys = task.Result;
            StateHasChanged();
        });
    }

    private async Task HandleFileAsync(ChangeEventArgs args)
    {
        using IDisposable? loadingHandle = App?.TryStartLoading();

        if (loadingHandle == null)
            return;

        FileKeyData[] fileKeys = await Cache.SaveAsync(FileInput, LoadToken);

        if (!fileKeys.Any())
            return;

        FileKeyData firstKey = fileKeys[0];
        NavigationManager.NavigateTo($"PQDIF/View/{firstKey.Key}");
    }

    private async Task TriggerFileInputAsync()
    {
        if (Loading)
            return;

        await JSRuntime.InvokeVoidAsync("pqdif.triggerClick", FileInput);
    }
}
